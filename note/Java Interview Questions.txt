1. OOPS concept
2. Interfaces
3. Abstract Classes and difference between them.
4. Methods Possesed by Object class in java.
5. JDK, JRE,JVM
6. Access Specifiers.
7. Aggregation vs Composition
8. Why Java Does support of pointers.
9. Multi Threading. Why MultiThreading?
10. Thread & Process.
11. Ways of implemeting MultiThreading.
12. User Thread & Daemon Thread.
13. Life Cycle Method of Thread.
14. Different Methods used in Multi-threading.
15. Synchronization
16. Synchronized Method, Synchronized Block & Static Synchronization
17. Exceptions vs Error.
18. Checked & Unchecked Exception
19. How to create a custom exception and how to throw it?
20. Differentiate between throw, throws and throwable.
21. Iterator vs listIterator.
22. String, String Buffer, String Builder, String Tokenizer.
23. Garbage Collection

Reader-Writer Problem
Producer-Consumer Problem.
----------------------------------------------------------------------------------------------------------------------------------
1. 
OOps Concept circulates arournd classes, Objects and 4 pillars of OOPs
Classes:- User Defined Blue print from which Object are created.
Objects:- They are instances of classes, They represent real life entities.
Abstraction:- It is a process, which displays only the information needed and hides the unnecessary information. We use Abstract classes and Interfaces for abstraction. 
Encapsulation:- It is defined as the wrapping up of data under a single unit. It bind together code and the data it manipulates.
Inheritance:- It is a properties in which one object inherits properties another object.
Polymorphism:- Polymorphism Means one name but many form. It is of 2 types:- 
	Overloading :- Happens when there exists many functions with same name but different parameters 
	Overriding :- Happens in case of inheritance.

2.
Interfaces helps us to define the behaviour of the class. In other words, it tells a class must do and not how.

3.
Abstract Class:- These are the classes that can not be instantiated. they are similar to interfaces that can not instantiated.

Abstract class vs Interface 

Type of methods: Interface can have only abstract methods. An abstract class can have abstract and non-abstract methods.
Final Variables: Variables declared in a Java interface are by default final. An abstract class may contain non-final variables.
Type of variables: Abstract class can have final, non-final, static and non-static variables. The interface has only static and final variables.
Implementation: Abstract class can provide the implementation of the interface. Interface can’t provide the implementation of an abstract class.
Inheritance vs Abstraction: A Java interface can be implemented using the keyword “implements” and an abstract class can be extended using the keyword “extends”.
Multiple implementations: An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java interfaces.
Accessibility of Data Members: Members of a Java interface are public by default. A Java abstract class can have class members like private, protected, etc.

4.
toString() - returns the String representation of the object.
clone() - return exact replica of an object. 
equals()
finalize()

5. 
JDK is S/W development environment used to develop applications.
JRE is implementation of JVM. It is set of S/W tools used to develop java applications.
JVM 

6. 
Public : Variables, method and classes declared as public can be accessed by any class or method.
Protected : Variables, method and classes declared as protected can be accessed with in that package and inherited class.
Private : Variables, method and classes declared as private can be accessed with in that class. 
Default : Variables, method and classes declared as default can be accessed with in that package.

7.
Aggregation represents weak relationship. Also called Is-A relationship. We can Implement a aggregation using inheritance.
Composition represents strong relationship. Also Called Has-A relationship. We can implement composition using "new" keyword.
For Example
Pulsar is a bike.
Bike has a engine.

8.
Pointers are kind of unsecured, and hence discouraged by java.

9.
Execute Multiple threads independently at the same time.
Why Multithreading? -> Efficient use of CPU.

10.
Thread:- Light weight and smallest unit of process.
Process:- Program in execution is called Process.

11.
	2 Ways of implementing thread in java.
		a. Extending Thread Class
		b. Implementing Runnable Interface.
	Implementing Runnable interface is better way.

12.
User Thread:- User threads have a specific life cycle and its life is independent of any other thread. 
		JVM waits for user threads to complete its tasks before terminating it. 
		When user threads are finished, JVM terminates the whole program along with associated daemon threads.
Daemon Thread:- daemon threads are basically referred to as a service provider that provides services and support to user threads. 
		There are basically two methods available in thread class for daemon thread: setDaemon() and isDaemon().

We can create daemon threads in java using the thread class setDaemon(true). We should set a thread as Daemon Thread before thread exeution starts.
isDaemon() method is generally used to check whether the current thread is daemon or not.

13.
	a. New
	b. Runnable
	c. Blocked/Waiting
	d. Timed Waiting.
	e. Terminated State.

14.
	a. start() -> begin the execution of a newly created thread. Thread can call the start() method only once.
	b. run() -> begin the execution of the same thread. Thread can call the run() method multiple times.
	c. wait() -> tells the calling thread (a.k.a Current Thread) to wait until another thread invoke’s the notify() or notifyAll() method for this object. 
			Here, Thread does loses its ownership of the resources and resume’s it’s execution only when resources are available after notify or notifyAll() is called.
			Belongs to Object Class.
	d. sleep() -> used to pause the execution of current thread for a specified time in Milliseconds. 
			Here, Thread does not lose its ownership of the resources and resume’s it’s execution.
			Belongs to Thread class.
	e. Notify() -> Wakes up only one thread that is in waiting state.
	f. NotifyAll() -> Wakes up all threads that are in waiting state.

15.
Two Types of Synchronization
	a. Process Synchronization
	b. Thread Synchronization
		i. Mutual Exclusion: Can be achieved using Synchronized Method, Synchronized Block, Static Synchronization	
		ii. Cooperation/Inter-thread communication

16.
Synchronized Method:- In this method, the thread acquires a lock on the object when they enter the synchronized method and releases the lock either normally or by throwing an exception when they leave the method.  
			No other thread can use the whole method unless and until the current thread finishes its execution and release the lock. 
			It can be used when one wants to lock on the entire functionality of a particular method. 
Synchronized Block:-  In this method, the thread acquires a lock on the object between parentheses after the synchronized keyword, and releases the lock when they leave the block. 
			No other thread can acquire a lock on the locked object unless and until the synchronized block exists. 
			It can be used when one wants to keep other parts of the programs accessible to other threads.
Static Synchronization:- 

Synchronized blocks should be preferred more as it boosts the performance of a particular program. 
It only locks a certain part of the program (critical section) rather than the entire method and therefore leads to less contention.

17.
Exception:- Abnormal condition that disrupts the normal flow of the program.
Error:- Error is caused by the environment in which the JVM is running, exceptions are caused by the program itself.

18.
Checked Exception:- Also called as Compile time Exeption. e.g. ClassNotFoundException, SQLException, IOException, etc
Unchecked Exception:- Also called as Run time exception. e.g. NumberFormatException, NullPointerException, ClassCastException, ArrayIndexOutOfBoundException, StackOverflowError etc.

20.
Throw -> ‘throw’ is used to throw an exception manually in Java. 
	Using this keyword, it is possible to throw an exception from any method or block.
Throws -> ‘throws’ is used in the method signature in Java. 
	If the method is capable of throwing exceptions, it is indicated by this method.
Throwable -> It is super class for all types of errors and exceptions in Java.
	In case customized exceptions are created, they should extend this class too.

21.
Iterator->
	a. Can traverse elements only in the forward direction.
	b. Helps to traverse Map, List and Set.
	c. Indexes cannot be obtained by using Iterator.
	d. Cannot modify or replace elements present in Collection.
	e. Cannot add elements and it throws ConcurrentModificationException.
	example: Iterator itr = collection.iterator();
		while(itr.hasNext()) { // add your code here.}

ListIterator -> 
	a. Can traverse elements both in forward and backward directions
	b. Can only traverse List and not the other two.
	c. It has methods like nextIndex() and previousIndex() to obtain indexes.
	d. Can modify or replace elements with the help of set(E e).
	e. Can easily add elements to a collection at any time.
	example: ListIterator ltr = list.listIterator();
		while (ltr.hasNext()) {// add your code here.}

For Examples 
22.
String vs String Buffer

String -> 
	a. String class is immutable.
	b. String is slow and consumes more memory when we concatenate too many strings because every time it creates new instance.
	c. String class uses String constant pool.
	d. To concat 2 Strings we use .concat method.
String Buffer-> 
	a. StringBuffer class is mutable.
	b. StringBuffer is fast and consumes less memory when we concatenate strings.
	c. StringBuffer uses Heap memory
	d. To concat 2 StringBuffers we need .append method.

String Buffer vs String Builder

String Buffer -> 
	a. StringBuffer is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.
	b. StringBuffer is less efficient than StringBuilder.
	c. Introduced in java 1.0
String Builder -> 
	a. StringBuilder is non-synchronized i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
 	b. StringBuilder is more efficient than StringBuffer thus String Builder is more advanced. 
	c. Introduced in java 1.5

String Tokenizer-> StringTokenizer class allows you to break a String into tokens.It is a legacy class of Java.

23.
Process of reclaming runtime unused memory automatically is called Garbage Collection.
It is automatically done by JVM.

24. Java 8 New Features
	a. Lambda Expressions :- similar to methods, but they do not need a name.
	b. Stream API
	c. Default methods in interface :- these are methods which are defined in interface and tagged as default. The implementation can be changed in child classes.
	d. Static Method :- these are methods which are defined in interface and keyword static. The implementation can't be changed in child classes.
	e. Functional Interface :- below
	f. Optional Class :- Container object which may or may not contain a non-null value.
	g. Method References :- special type of lambda expression in which we reference existing methods. It uses ::(double colon)
	h. Date API
	i. Nashdoem javascript Engine

25. Functional Interfaces in Java
	They are the interface which have only one abstract method.
	It can have any number of static and default method
	Example of functional Interface is Runnable, Comparable.
	Functional interfaces were introduced in Java 8 in order to implement lambda expressions.
	
	We can create our own functional interface.
	To create our own functional interface, we need to follow the following steps:- 
	a. Create an interface.
	b. Annotate it with @FunctionalInterface
	c. define only one abstract method. (Abstract method does not have a body)
	d. (Optional) Create any static or default methods.
	
	Example of Functional Interface:-
	@FunctionalInterface
	public interface FunctionalInterface {
		void singleAbstractMethod(); // Abstract Method
		default void defaultMethod(){
			System.out.println("This is default Method"); // This is optional
		}
	}
	
	Fun Fact :- before java 8, we can only use abstract methods in java interfaces.
26. Different ways of Iterating hashmap in java

27. Method Referencing In Java 8.
	It is a special type of lambda expression in which we reference existing methods. It uses ::(double colon)
	Type Of method referenece
	a. Static Method Reference.
		If a lambda expression just call a static method of a class 
		(args) -> Class.staticMethod(args) 
		Shorthand if a lambda expression just call a static method of a class 
		Class::staticMethod  
	b. Instance Method Reference of a particular object.
		If a lambda expression just call a default method of an object 
		(args) -> obj.instanceMethod(args) 
		Shorthand if a lambda expression just call a default method of an object
		obj::instanceMethod
	c. Instance Method Reference of an arbitrary object of a particular type.
		
	d. Constructor Reference.

28. What are predicates? 
	Predicate is a predefined Functional Interface (Having only 1 abstract method).
	The only abstract method of predicate is test(T t):
	public boolean test(T t);
	Whenever we want to check some boolean condition then you can go for Predicates. 
	Predicate return type is always boolean.
	Predicate Joining is used when we want to combine multiple predicates to five single results.
	There are 3 ways to join a predicate.
		a. And example:- Predicate1.and(Predicate2).test("the value which we want to test")
		b. Or example:- Predicate1.or(Predicate2).test("the value which we want to test")
		c. Negate example:- Predicate1.negate().test("the value which we want to test")

29. What are Functions in Java 8.
	Function is also a predefined Functional Interface (Having only 1 abstract method).
	The only abstract method of Function is apply(T t);
	Working of functions is such a way that "If we give some input & perform some output. This output can any thing (not necessarily a boolean value)"
	In functions return type is not fixed. Hence we have to declare both input type and return type.
	Just like predicate joining, we have functional chaining.
	We can combine / chain multiple functions together with andThen abd compose.

	There are two ways to combine functions:
	f1.andThen(f2).apply(Input);  - first f1 then f2 // from left to right
	f1.compose(f2).apply(Input)  - first f2 then f1 // from right to left


Multiple functions can be chained together like :
f1.andThen(f2).andThen(f3).andThen(f4).apply(Inputs);

30. What are Consumer Functional Interface in Java8.
	It is predefined Functional Interface which never return anything (never supply), they just consume.
	The only abstract method is accept.
	c1.andThen(c2).accept(Input);  - first c1 then c2.
	Multiple consumers can be chained together like :
	c1.andThen(c2).andThen(c3).andThen(c4).accept(Inputs);
	
31. What is Supplier Functional Interface in Java 8.
	It is functional Interface which does not takes any input but it will always supply an object.
	The only abstract method is get(T t);
	There is no chaining as no input is given.
	It is just opposite of Consumer.
	Example: always supply me current date.
	
32. Stream API.
	It is special Iterator class that allow processing collection of Objects in a functional manner.
	In simple words : Stream is sequence of Objects which supports various methods that gives desired result.
						Stream API is used to process these collection of Objects.
	
33. Optional in java 8
	Optional is a container object which may or may not contain a non-null value.
	Some important methods in Optional Class are 
	a. isPresent() - Return true if there is a value present, otherwise false.
	b. get() - If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.
	c. ofNullable(T value) - if non-null, Returns an Optional describing the specified value otherwise returns an empty Optional.

**************************************************
Facts
**************************************************
1. Static method can be overloaded but can not be overrided.
2. Private method can not be overridden because it will not be visible in child class.
3. Can Classes be private? Classes can be private only if they are nested classes. Top level classes can't be private.
4. Can we call static method from another static method? Yes, A static method can call only other static methods; it cannot call a non-static method.
5. Can we call static method from non static method? Yes
6. Can we have static classes in java? Yes we can make nested classes as static, Top level classes can not be static.
7. If we change the order of public static void main to static public void, then program will run flawlessly.  
8. We can not make constructor as static or final
9. Can we override A constructor? No, it will give a compile time error.
10. Difference Equals Method of Object class and String class. Object class method checks address of 2 objects where as String class method checks equallity of 2 strings.

