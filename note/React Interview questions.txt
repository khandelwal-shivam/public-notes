1. DOM
DOM = Document Object Model. 
Document = HTML document. 
Object = Everything inside document i.e. all HTML Tags.
Model = Layout or Structure.
So DOM is the layout of the Obejcts or HTML tags in a document or HTML document.

2. Virtual DOM
Virtual DOM = Exact Replica of DOM, upon which React performs all the operations.
	for example:- if we change a state then these changes will be applied to virtual dom

3. JSX
JSX = Acronym for JavaScript XML.
Browser's can't read JSX directly. Browser understand HTML,CSS and JS. JSX is converted to JS using JSX transformers.

4. HOC
HOC = Acronym for Higher Order Component.  
It is a function which takes a component as argument and returns a component. 
A normal component is function which takes props and return a component.
Commonly used in third party react libraries.

5. State
State is an Object that is used to contain data or information about the component. Whenever state changes the component re-renders.

6. Props
Props is an acronym for properties.
They act as input to components.

7. Child Props
Children props allow us to pass components as data to other components.
It is used to display whatever you include between the opening and closing tags when invoking a component.
For E.g.
const Picture = (props) => {
  return (
    <div>
      <img src={props.src}/>
      {props.children}
    </div>
  )
}

return (
    <div className='container'>
      <Picture key={picture.id} src={picture.src}>
          //what is placed here is passed as props.children  
      </Picture>
    </div>
  )

Instead of invoking the component with a self-closing tag <Picture /> if you invoke it will full opening and closing tags <Picture> </Picture> you can then place more code between it.
This de-couples the <Picture> component from its content and makes it more reusable.

8. React Fragments 
Fragments allow us to group a list of children without adding extra nodes to the DOM.
We can use <React.Fragment></React.Fragment> or its shorter syntax <></>

9. Lifecycle method of React
LifeCycle of React depends on the Stage
React contains 3 stages

a. Mounting
b. Updating
c. UnMounting

Mounting contains 4 lifecycle methods: 
	constructor
	getDerivedStateFromProps()
	render()
	componentDidMount()
Updating contains 5 lifecycle methods:
	getDerivedStateFromProps()
	shouldComponentUpdate()
	render()
	getSnapshotBeforeUpdate()
	componentDidUpdate()
Unmounting contains 1 lifecycle method
	componentWillUnmount()

10. PropTypes
PropTypes = It determines the type of prop. It can be string, bool, func, array, number, Object etc.
Need Example

11. Redux
Redux is a javascript library that is used for state management.
It has 3 parts (actions,reducers,store).
(Need Implementation)
actions: Actions are plain JavaScript object that must have a type attribute to indicate the type of action performed.
	
reducers: Reducers are functions that take the current state and an action as arguments, and return a new state result. 
		In other words, (state, action) => newState.
		We can have root reducer. Here we need to have combine reducer, to combine multiple reducers into root reducers.

Store: it is where our redux state is saved.

12.Synthetic Events
Event handlers in React JS will be passed as instances of SyntheticEvent.
SyntheticEvent is a cross-browser wrapper around the browser’s native event.
It has the same interface as the browser’s native event, including stopPropagation() and preventDefault(), except the events work identically across all browsers.

13. Refs
Refs means reference to the element.
They should be avoided in most cases, however, they can be useful when we need a direct access to the Real DOM element. 
refs don't apply changes to virtual dom.

14. Reconsilation
Reconsilation is a process in which Virtual dom is compared with Real DOM for finding the changes that are need to be made in real DOM.
Renderer then uses the information provided by reconciliation process to actually update the rendered app.
React uses diffing algorithm for reconciliation. It follows a heuristic approach with complexity of O(n).
Diffing Algo is based on 2 assumptions:-
	a. Two elements(HTML tags in laymen terms) of different types will produce different trees.
	b. The developer can hint at which child elements may be stable across different renders with a "key" prop.
Not So important.
React Reconciler is a part of diffing algo. React Fiber is a reimplementation of the React reconciler.
It was needed to be re-written because it is based on recursion (thus was called React Stack) and need further improvisations.

15. Hooks
Hooks are the functions which "hook into" or connect to React state and lifecycle features from function components.

16. key prop
Keys help React identify which items have changed, are added, or are removed.

17. useState 
useState is a Hook that allow us to add React state to function components.

18. useEffect
useEffect is a Hook which allow to perform sideEffect.It is equivalent to componentDidMount(), componentDidUpdate(), and componentWillUnmount() life cycle methods.
Side Effect means Fetching Data from server API, updating DOM, etc.

19. useContext 
useContext is helpful when we are working with Context API.
To avoid the problem of prop drilling we use context api.

20. useMemo
useMemo & React.memo both are used in optimizations.
React.memo is a HOC. If our component renders the same result for same props we can wrap it in a call to React.memo.
By Wrapping, React will skip rendering the component and reuse the last rendered value.

useMemo memoizes the return value from the function so it doesn't run on every render. This way react doesn't need to do additional computations when running the function. 
useMemo takes 2 arguments (a function which will return a value and a dependenct array like useEffect).
The function passed passed into useMemo will recompute when one of the value passed in dependency array changes.
We prefer to use useMemo for big and expensive processings.

21. useRef 
useRef is helpful when we need to access any dom element and to modify it.

22. useCallback 
useCallBack memoize the entire function so it doesn't get created on every render. This improves the performance as memoized function is used on re-renders.
It takes 2 arguments(first argument is actual function that we want to memoize and second argument is dependency array just like useEffect) and returns a new function. 
We prefer to use useCallback to cache callbacks to prevent unnecessary component re-rendering.

23. creating custom hook. e.g. useForm (not done)

24. When does a react component re-renders

25. Context API
Context API provides a way to pass data through the component tree without having to pass props down manually at every level.
It is used for state management.
Context API is best suited for small applications & Redux is best suited for large Applications.






27. Pure Component
Pure Components in React are the components which do not re-renders when the value of state and props has been updated with the same values. 
If the value of the previous state or props and the new state or props is the same, the component is not re-rendered. 
Pure Components restricts the re-rendering ensuring the higher performance of the Component.
It is basically for class based components. For functional components we use Memo

28. useHistory 
useHistory provide access to history prop in react router.
A primary use case would be for routing with functions, like push, replace, etc.

29. useLocation
useLocation provide access to location prop in react router.
A primary use case would be to access the query params or the complete route string.

30. useParams
useParam provide access to search parameters in the url.

31. useRouteMatch
useRouteMatch

32. Error Boundry
Error Boundries are  react components that 
	a. catches javascript errors anywhere in their child component tree,
	b. log those errors.
	c. display a fallback UI instead of component tree that crashed
A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). 
Use getDerivedStateFromError() to render a fallback UI after an error has been thrown. 
Use componentDidCatch() to log error information.

33. Portals
Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.
we can create portal using ReactDOM.createPortal
e.g.
ReactDOM.createPortal(<JSX>, container-except-root)
Explain the use of portals.

34. Fetching data from Service
Get Request
fetch("url")
.then(response=>{
console.log(response)	
})
.catch(error => {
console.log(error)
})

Post Request
fetch('https://example.com/profile', {
  method: 'POST', // or 'PUT'
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(data),
})
.then(response => {
	console.log(response)
})
.catch(error => {
	console.log(error)
})
**************************************
Get request
axios.get(URL).then((response) => {
      console.log(response.data);
    });

Post Request
axios.post(URL, {
        title: "Hello World!",
        body: "This is a new post."
      })
      .then((response) => {
        console.log(response.data);
      });
  }
Axios is better than fetch. 
I have used both and found axios to be better than fetch because 
	Axios has better error handling. It throws 400 and 500 range errors for us. 
	Unlike the Fetch API, where you have to check the status code and throw the error yourself.
	
	With axios we don't need to set headers and converting request body to JSON string. Axios do all these things for us which lacks in Fetch.  

35. Controlled v/s Uncontrolled Component
Controlled Component is one that takes its current value through props and notifies changes through callbacks like "onChange"
In a controlled component, the value of the input element is controlled by React.
for example:- <input type="text" value={value} onChange={handleChange} />

Uncontrolled Component query the DOM using a "ref" to find its current value when we need it.
In an uncontrolled component, the value of the input element is handled by the DOM itself.
for example:- <input type="text" defaultValue="foo" ref={inputRef} />
// Use `inputRef.current.value` to read the current value of <input>

36. Strict Mode
StrictMode is a tool added in the version 16.3 of React to highlight potential problems in an application. 
It performs additional checks on the application.
StrictMode currently helps with the following issues:
	1. Identifying components with unsafe lifecycle methods.
	2. Warning about the usage of legacy string API.
	3. Warning about the usage of findDOMNode. findDOMNode( ) method was used to search the tree of a DOM node.

37. When does React Component re-renders
Re-rendering of a component and it’s child components occur when props or state of the component has been changed.
Re-rendering components that are not updated, affects the performance of an application.

38. Lazy Loading.
Lazy Loading is also called Code Splitting.
React has a concept of Component Based Architecture which means that instead of building our application as a whole we split our application into multiple reuseable components.
Now when we do production build at that time webpack(under the hood) will bundle all of the component and it will generate bundle.js file.
On initial request to any react application the server sends back a bare minimum HTML file which links to bundle.js file.
If our application is huge then the JS bundle will take a long time to download & execute the script file which in turn lead to performance loss.
To avoid the performance loss we use code splitting. React Lazy & Suspense are preferred way to do code splitting in react applications.
React.lazy taskes a function that must call a dynamic import(). 
The lazy component should then be rendered inside the suspense component, which allow us to show fallback content(such as loading indicator) while we wait for lazt component to load.
Now instead of generating one massive "bundle.js" file webpack will generate components based chunk files which are smaller in size.

For Example:-
Let's assume we have a "Profile" component and we have applied code splitting.
Whenever we visits "Profile" page at that time React will dynamically load that component.
It simply means that code for "Profile" component is not initially included in initial "bundle.js" file that gets sent to the client.
Instead, a seperate chunk file is created for the Profile component which only gets downloaded when user visits that component.

Syntax
Lazy Loading using <Suspense>
	1. Import the component that will be loaded lazily. e.g. const UserProfile = React.lazy(() => import('./UserProfile.js'));
	2. Wrap the imported component with <Suspense>. 
		e.g. <Suspense fallback = {<p>Loading....</p>}>
			<UserProfile/>
		     </Suspense>. 
	3. fallback prop accepts a component that will be visible until the actual component loads.

39. How to change port number in react js.

40. Authentication in React js.
One of the promising and best way is to use JWT. We will store the JWT token & store it in local storage.
This token can be appended in header to every or some axios request in Header.
Case 1 If we want to append the token to every request.
	axios.interceptors.request.use(request=>{
		request.headers.authorization = localStorage.getItem("jwt_token");
	});
Case 2 If we want to append token to only some requests
	const authAxios = axios.create({
		baseUrl: apiUrl,
		headers: {
			Authorization: localStorage.getItem("jwt_token")
			}
	})
Now Our actual Url becomes -> const result = await authAxios.get('/users/all');

41. Cookies in react js.
Cookies are the data stored in the form of key-value pairs that are used to store information about the user on their computer by the websites that the users browse and use it to verify them. 
To set or remove the cookies, we are going to use a third-party dependency of react-cookie

42. How to store data in browser storage
Storing data in browser storage.
	localStorage.setItem("jwt_token", "fsdhf213e23rfsewedwsdewurt326.fdafgduhgcu974rt4efvdfgywg.fddsugvsucvu723r743gfc843yef);
getting data in browser storage.
	localStorage.getItem("jwt_token");
clearing localStorage
	localStorage.clear();

43. What is React js
React Js is frontend library which follows unidirectional data flow(from parent to child). 
	We follow modular approach i.e. we create components in react which are reuseable in nature.
44.
New Features in React 17

45. What is Component
Component is reuseable block of code (just like functions) which returns jsx.

46. Creating class component v/s function component syntax


*******************Class based component***********************
class Car extends React.Component {
  render() {
    return <h2>Hi, I am a Car!</h2>;
  }
}

******************Function based component********************
const Car = (props) => {
return(<h2>Hi, I am a Car!</h2>);
}
47. What is React Routing
React Routing:- Moving from one page to another page via a provided path

48. What are Interceptors
Interceptors are the default configurations that are added automatically to every api request or response that a user receives.

49. Progressive Web Apps

50. How To set Up Microfrontends in React Js.
Source
https://dev.to/kpiteng/microfrontends-with-react-47jb

Step 1
Lets create 3 applications Header,Blogs & Container

Container Application - Port 3000
Header Application - Port 3001
Blogs Application - Port 3002

Step 2 Setting Up Microfrontends

2.1 update package.json
	Container Application -> "scripts": { "start": "PORT=3000 react-app-rewired start",}
	Header Application -> "scripts": {"start": "PORT=3001 react-app-rewired start",}
	Blogs Application -> "scripts": {"start": "PORT=3002 react-app-rewired start",}

2.2 Create .env file in root directory of Container Application
	REACT_APP_HEADER_HOST=http://localhost:3001
	REACT_APP_BLOGS_HOST=http://localhost:3002

2.3 Create a MicroFrontend.js file in Container App, which has business logic for mount, unmount components
	Note:- React App bundle entire applications to main.js, Where we have functions to render, mount, unmount components.
	
	Take The MicroFrontend file from the link above.
	
	MicroFrontend component will take name, host and history as params. 
	The fetch function which fetch the asset-manifest.json from the host and create a script object using the main.js and it will use the render function to mount components.

2.4 Install react-app-rewired package.
	react-app-rewired provides a file, (config-overrides.js) placed in your project root directory where you can override existing behaviour
	overide the code with the code provided in the link above.

2.5 Update build, test & eject scripts in package.json
	"scripts": {
		"start": "PORT=3002 react-app-rewired start",
		"build": "react-app-rewired build",
		"test": "react-app-rewired test",
		"eject": "react-app-rewired eject"
	}
	In similar way update for Header and Container (change the port number)
	
2.6 Update Index.js file of each microfrontend adding window.unmouting and window.rendering logics
	These logics are present in above mentioned link.
 
----------------------------------------------------------------------------------------------------------------------------------

	
